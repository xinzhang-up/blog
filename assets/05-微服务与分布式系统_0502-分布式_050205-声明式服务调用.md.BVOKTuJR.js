import{_ as e,c as r,o as a,ag as l}from"./chunks/framework.CP8pidWN.js";const i="/blog/assets/1742215421994.BuLtUiLD.png",n="/blog/assets/1742215439957.CuHEdOP5.png",o="/blog/assets/1742215583178.DqJ_cT_a.png",d="/blog/assets/1742215812164.CJReKn9L.png",s="/blog/assets/1742217229230.bNDHoysX.png",p="/blog/assets/1742217409268.B2k-r8g5.png",c="/blog/assets/1742217467154.Bs_rMe2k.png",_="/blog/assets/1742217626952.BNbreeyt.png",H=JSON.parse('{"title":"声明式服务调用","description":"","frontmatter":{},"headers":[],"relativePath":"05-微服务与分布式系统/0502-分布式/050205-声明式服务调用.md","filePath":"05-微服务与分布式系统/0502-分布式/050205-声明式服务调用.md"}'),g={name:"05-微服务与分布式系统/0502-分布式/050205-声明式服务调用.md"};function h(u,t,m,b,f,q){return a(),r("div",null,t[0]||(t[0]=[l('<h1 id="声明式服务调用" tabindex="-1">声明式服务调用 <a class="header-anchor" href="#声明式服务调用" aria-label="Permalink to &quot;声明式服务调用&quot;">​</a></h1><h2 id="springcloud-openfeign" tabindex="-1">SpringCloud OpenFeign <a class="header-anchor" href="#springcloud-openfeign" aria-label="Permalink to &quot;SpringCloud OpenFeign&quot;">​</a></h2><blockquote><p>参考:<a href="https://mp.weixin.qq.com/s/rQqDg9KlfWfVBIPsDO_A9w" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/rQqDg9KlfWfVBIPsDO_A9w</a></p></blockquote><h3 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h3><p><img src="'+i+'" alt="1742215421994"></p><h3 id="核心组件" tabindex="-1">核心组件 <a class="header-anchor" href="#核心组件" aria-label="Permalink to &quot;核心组件&quot;">​</a></h3><p><img src="'+n+'" alt="1742215439957"></p><ul><li><p>Contract, Feign在构建动态代理时, 解析方法上的注解和参数, 获取http请求需要用到的参数等; SpringCloud做了自己的实现</p></li><li><p><img src="'+o+'" alt="1742215583178"></p></li><li><p>Encoder, 将请求体方法参数序列化成字节数组</p></li><li><p>Decoder, 将响应体中的字节流反序列化成方法返回值类型的对象</p></li><li><p>Client, 动态代理对象, 最终用来执行http请求的组件</p><ul><li>默认为HttpUrlConnection, 也有基于HttpClient, 以及OkHttp的实现</li><li>当然也有Ribbon的</li><li><img src="'+d+'" alt="1742215812164"></li></ul></li><li><p>InvocationHandlerFactory, 创建InvocationHandler的工厂, 对于JDK动态代理来说，必须得实现InvocationHandler才能创建动态代理</p><ul><li>限流熔断框架Hystrix和Sentinel都实现了自己的InvocationHandler, 这样就可以对MethodHandler执行前后，也就是Http接口调用前后进行限流降级等操作。<img src="'+s+'" alt="1742217229230"></li></ul></li><li><p>RequestInterceptor, 请求拦截器</p></li><li><p>Retryer, 重试组件, springcloud重新实现了, 默认不重试</p></li></ul><p>总结</p><table tabindex="0"><thead><tr><th>接口</th><th>作用</th><th>Feign默认实现</th><th>Spring实现</th></tr></thead><tbody><tr><td>Contract</td><td>解析方法注解和参数，将Http请求参数和方法参数对应</td><td>Contract.Default</td><td>SpringMvcContract</td></tr><tr><td>Encoder</td><td>将请求体对应的方法参数序列化成字节数组</td><td>Encoder.Default</td><td>SpringEncoder</td></tr><tr><td>Decoder</td><td>将响应体的字节流反序列化成方法返回值类型对象</td><td>Decoder.Default</td><td>SpringDecoder</td></tr><tr><td>Client</td><td>发送Http请求</td><td>Client.Default</td><td>LoadBalancerFeignClient</td></tr><tr><td>InvocationHandlerFactory</td><td>InvocationHandler工厂，动态代理核心逻辑</td><td>InvocationHandlerFactory.Default</td><td>无</td></tr><tr><td>RequestInterceptor</td><td>在发送Http请求之前，再对Http请求的内容进行拦截修改</td><td>无</td><td>无</td></tr><tr><td>Retryer</td><td>重试组件</td><td>Retryer.Default</td><td>无</td></tr></tbody></table><h3 id="运行原理" tabindex="-1">运行原理 <a class="header-anchor" href="#运行原理" aria-label="Permalink to &quot;运行原理&quot;">​</a></h3><ul><li>动态代理生成流程</li><li><img src="'+p+'" alt="1742217409268"></li><li>Http调用执行流程</li></ul><p><img src="'+c+'" alt="1742217467154"></p><ul><li>FeignClient接口注册到Spring的流程 <img src="'+_+'" alt="1742217626952"></li></ul>',14)]))}const C=e(g,[["render",h]]);export{H as __pageData,C as default};

import{_ as l,c as e,o as i,ag as r}from"./chunks/framework.DPDPlp3K.js";const t="/assets/1741490699035.DZ5Er64I.png",P=JSON.parse('{"title":"分布式理论","description":"","frontmatter":{},"headers":[],"relativePath":"05-微服务与分布式系统/0502-分布式/050201-分布式理论.md","filePath":"05-微服务与分布式系统/0502-分布式/050201-分布式理论.md"}'),o={name:"05-微服务与分布式系统/0502-分布式/050201-分布式理论.md"};function h(s,a,n,d,u,c){return i(),e("div",null,a[0]||(a[0]=[r('<h1 id="分布式理论" tabindex="-1">分布式理论 <a class="header-anchor" href="#分布式理论" aria-label="Permalink to &quot;分布式理论&quot;">​</a></h1><p>分布式系统主要解决单机性能瓶颈导致的成本问题</p><h2 id="理论" tabindex="-1">理论 <a class="header-anchor" href="#理论" aria-label="Permalink to &quot;理论&quot;">​</a></h2><h3 id="cap" tabindex="-1">CAP <a class="header-anchor" href="#cap" aria-label="Permalink to &quot;CAP&quot;">​</a></h3><p>CAP理论主张任何基于网络的数据共享系统, 都最多只能拥有以下三条中的两条:</p><ul><li>一致性(Consistency), 所有节点访问同一份最新的数据副本</li><li>可用性(Availability), 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</li><li>分区容错性(Partition Tolerance), 分布式系统出现网络分区的时候，仍然能够对外提供服务 <ul><li>网络分区: 分布式系统节点之间因为故障而不连通, 整个网络分成了几块区域</li></ul></li></ul><p>直白一点的解释, 分布式系统中, 在满足分区容错的前提下, 没有算法能同时满足数据一致性和服务可用性</p><ul><li>CP架构: ZooKeeper、HBase</li><li>AP架构: Cassandra、Eureka</li><li>特殊: Nacos都支持</li></ul><h3 id="base" tabindex="-1">BASE <a class="header-anchor" href="#base" aria-label="Permalink to &quot;BASE&quot;">​</a></h3><p>BASE 是 Basically Available（基本可用）、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写</p><ul><li>BASE理论是对AP方案的一个补充</li></ul><h3 id="分布式共识算法" tabindex="-1">分布式共识算法 <a class="header-anchor" href="#分布式共识算法" aria-label="Permalink to &quot;分布式共识算法&quot;">​</a></h3><h4 id="paxos算法" tabindex="-1">Paxos算法 <a class="header-anchor" href="#paxos算法" aria-label="Permalink to &quot;Paxos算法&quot;">​</a></h4><h4 id="raft算法" tabindex="-1">Raft算法 <a class="header-anchor" href="#raft算法" aria-label="Permalink to &quot;Raft算法&quot;">​</a></h4><h2 id="分布式系统设计" tabindex="-1">分布式系统设计 <a class="header-anchor" href="#分布式系统设计" aria-label="Permalink to &quot;分布式系统设计&quot;">​</a></h2><h3 id="分布式文件系统" tabindex="-1">分布式文件系统 <a class="header-anchor" href="#分布式文件系统" aria-label="Permalink to &quot;分布式文件系统&quot;">​</a></h3><ul><li>HDFS</li><li>GFS</li></ul><h3 id="分布式消息队列" tabindex="-1">分布式消息队列 <a class="header-anchor" href="#分布式消息队列" aria-label="Permalink to &quot;分布式消息队列&quot;">​</a></h3><ul><li>Kafka</li><li>Pulsar</li></ul><h3 id="分布式缓存" tabindex="-1">分布式缓存 <a class="header-anchor" href="#分布式缓存" aria-label="Permalink to &quot;分布式缓存&quot;">​</a></h3><ul><li>Redis Cluster</li><li>Codis</li></ul><h3 id="分布式数据库" tabindex="-1">分布式数据库 <a class="header-anchor" href="#分布式数据库" aria-label="Permalink to &quot;分布式数据库&quot;">​</a></h3><h3 id="微服务框架" tabindex="-1">微服务框架 <a class="header-anchor" href="#微服务框架" aria-label="Permalink to &quot;微服务框架&quot;">​</a></h3><h2 id="分布式系统问题" tabindex="-1">分布式系统问题 <a class="header-anchor" href="#分布式系统问题" aria-label="Permalink to &quot;分布式系统问题&quot;">​</a></h2><h3 id="分布式计算" tabindex="-1">分布式计算 <a class="header-anchor" href="#分布式计算" aria-label="Permalink to &quot;分布式计算&quot;">​</a></h3><ul><li>怎么找到服务, 服务注册与发现, AP/CP</li><li>怎么找到实例, 负载均衡策略（轮询、权重、Hash、一致性 Hash，FAIR 等各种策略的适用场景）</li><li>怎么管理配置, 多实例使用统一的配置中心</li><li>怎么进行协同, 分布式锁</li><li>怎么确保请求只执行一次, 重试+幂等</li><li>怎么避免雪崩, 快速失败和降级（熔断、降级、限流 等）;弹性扩容</li><li>怎么监控告警和故障恢复, 分布式系统监控, 分布式追踪Trace, 模拟故障的混沌工程以及相关的告警等 机制</li></ul><h3 id="分布式存储" tabindex="-1">分布式存储 <a class="header-anchor" href="#分布式存储" aria-label="Permalink to &quot;分布式存储&quot;">​</a></h3><ul><li>怎么做数据分片, Hash 和 Region 分片</li><li>怎么做数据复制, 中心化方案（主从复制、一致性协议，比如 Raft 和 Paxos 等）和 去中心化的方案（ Quorum 和 Vector Clock）</li><li>怎么做分布式事务, 先有事务ID, 再通过 2PC 或者 3PC 协议来实现分布式事务的原子性</li></ul><p>总结:</p><p><img src="'+t+'" alt="1741490699035"></p>',30)]))}const q=l(o,[["render",h]]);export{P as __pageData,q as default};

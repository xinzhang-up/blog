import{_ as l,c as e,o as i,ag as t}from"./chunks/framework.DPDPlp3K.js";const o="/assets/1742389863917.ptqP7DfG.png",s="/assets/1742389891893.TA1oCtyf.png",r="/assets/1742389916213.C_c9KyA_.png",n="/assets/1742389948806.Czm1TPAk.png",c="/assets/1742389986689.3-m2luVd.png",p="/assets/1742390021734.D5Hwl5Ox.png",h="/assets/1742390054123.B6DM5WAC.png",d="/assets/1742390080127.fyXQrCeT.png",u="/assets/1742390141047.BmjTpzoE.png",_="/assets/1742390161934.DkIehpMw.png",k=JSON.parse('{"title":"IO模型","description":"","frontmatter":{},"headers":[],"relativePath":"02-Java语言基础/0201-Java核心知识点/020102-IO模型.md","filePath":"02-Java语言基础/0201-Java核心知识点/020102-IO模型.md"}'),I={name:"02-Java语言基础/0201-Java核心知识点/020102-IO模型.md"};function O(m,a,f,g,b,q){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="io模型" tabindex="-1">IO模型 <a class="header-anchor" href="#io模型" aria-label="Permalink to &quot;IO模型&quot;">​</a></h1><p>一次IO过程如下</p><ul><li>应用程序进程向操作系统发起IO调用请求</li><li>操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区</li><li>操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区</li></ul><p><img src="'+o+'" alt="1742389863917"></p><h2 id="阻塞io-bio" tabindex="-1">阻塞IO(BIO) <a class="header-anchor" href="#阻塞io-bio" aria-label="Permalink to &quot;阻塞IO(BIO)&quot;">​</a></h2><ul><li>如果内核数据内有准备好, 那么用户进程将一直阻塞, 浪费CPU资源</li><li>应用: 阻塞socket、Java BIO</li><li><img src="'+s+'" alt="1742389891893"></li></ul><h2 id="非阻塞io-nio" tabindex="-1">非阻塞IO(NIO) <a class="header-anchor" href="#非阻塞io-nio" aria-label="Permalink to &quot;非阻塞IO(NIO)&quot;">​</a></h2><ul><li>应用进程轮询调用系统内核</li><li>频繁轮询依然消耗CPU资源</li><li><img src="'+r+'" alt="1742389916213"></li></ul><h2 id="多路复用io" tabindex="-1">多路复用IO <a class="header-anchor" href="#多路复用io" aria-label="Permalink to &quot;多路复用IO&quot;">​</a></h2><h3 id="select" tabindex="-1">select <a class="header-anchor" href="#select" aria-label="Permalink to &quot;select&quot;">​</a></h3><ul><li>应用进程通过select函数询问内核数据是否准备就绪, 数据就绪后再发起系统调用</li><li>缺点 <ul><li>监听的IO最大连接数在Liunx上最大为1024</li><li>select函数返回后, 需要遍历所有流才能找到就绪的描述符fd, 如果同时连接大量的客户端, 同一时刻可能只有极少数流处于就绪状态, 随着监视的描述符数量增长, 效率也会线性下降</li></ul></li><li>poll模型解决了连接数的限制, 但解决不了遍历所有流的问题</li><li><img src="'+n+'" alt="1742389948806"></li></ul><h3 id="epoll" tabindex="-1">epoll <a class="header-anchor" href="#epoll" aria-label="Permalink to &quot;epoll&quot;">​</a></h3><ul><li>采用监听事件回调机制, 先通过epoll_ctl()注册一个文件描述符fd, 一旦某个fd就绪时, 内核会采用回调机制, 迅速激活fd, 当进程调用epoll_wait()时便得到通知</li><li>进程调用epoll_wait()时依然有可能被阻塞</li><li><img src="'+c+'" alt="1742389986689"></li></ul><h3 id="select-poll-epoll-对比" tabindex="-1">select, poll, epoll 对比 <a class="header-anchor" href="#select-poll-epoll-对比" aria-label="Permalink to &quot;select, poll, epoll 对比&quot;">​</a></h3><p><img src="'+p+'" alt="1742390021734"></p><h2 id="信号驱动模型" tabindex="-1">信号驱动模型 <a class="header-anchor" href="#信号驱动模型" aria-label="Permalink to &quot;信号驱动模型&quot;">​</a></h2><ul><li>不再主动询问内核数据是否就绪, 而是向内核发送一个信号, 然后应用进程去做别的事, 不用阻塞, 当内核数据准备好后, 再通过信号通知应用进程, 应用进程收到信号立刻读取数据</li><li><img src="'+h+'" alt="1742390054123"></li></ul><h2 id="异步io-aio" tabindex="-1">异步IO(AIO) <a class="header-anchor" href="#异步io-aio" aria-label="Permalink to &quot;异步IO(AIO)&quot;">​</a></h2><ul><li>上面的BIO, NIO, 信号驱动等模型, 在数据从内核复制到应用缓冲的时候都是阻塞的, 异步IO实现了IO全流程的非阻塞, 在应用进程发出系统调用后, 立即返回成功, 等内核数据拷贝完成后再通知用户进程操作执行完毕</li><li><img src="'+d+'" alt="1742390080127"></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><img src="'+u+'" alt="1742390141047"></p><h2 id="java-nio" tabindex="-1">JAVA NIO <a class="header-anchor" href="#java-nio" aria-label="Permalink to &quot;JAVA NIO&quot;">​</a></h2><ul><li>**传统 **<strong>NIO</strong> 是操作系统级别的非阻塞 I/O 机制, <strong>Java NIO</strong> 是 Java 对传统 NIO 的封装和扩展，提供了更高效的 I/O 操作方式</li><li>NIO 主要有三大核心部分： Channel(通道)， Buffer(缓冲区), Selector.</li></ul><p>传统 IO 基于字节流和字符流进行操作， 而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p>NIO 和传统 IO 之间第一个最大的区别是， IO 是面向流的， NIO 是面向缓冲区的。</p><p><img src="'+_+'" alt="1742390161934"></p>',26)]))}const x=l(I,[["render",O]]);export{k as __pageData,x as default};

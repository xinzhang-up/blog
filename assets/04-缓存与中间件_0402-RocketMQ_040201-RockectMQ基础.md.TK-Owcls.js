import{_ as t,c as o,o as r,ag as a}from"./chunks/framework.CP8pidWN.js";const c="/blog/assets/1741672169412.BIVQS8X7.png",s="/blog/assets/1741676091669.BX_iXohY.png",l="/blog/assets/1741676284240.tbFzHB2i.png",u=JSON.parse('{"title":"RocketMQ基础","description":"","frontmatter":{},"headers":[],"relativePath":"04-缓存与中间件/0402-RocketMQ/040201-RockectMQ基础.md","filePath":"04-缓存与中间件/0402-RocketMQ/040201-RockectMQ基础.md"}'),i={name:"04-缓存与中间件/0402-RocketMQ/040201-RockectMQ基础.md"};function n(p,e,m,k,_,h){return r(),o("div",null,e[0]||(e[0]=[a('<h1 id="rocketmq基础" tabindex="-1">RocketMQ基础 <a class="header-anchor" href="#rocketmq基础" aria-label="Permalink to &quot;RocketMQ基础&quot;">​</a></h1><blockquote><p><a href="https://rocketmq.apache.org/zh/docs" target="_blank" rel="noreferrer">https://rocketmq.apache.org/zh/docs</a></p></blockquote><h2 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h2><p><img src="'+c+'" alt="1741672169412">如何保证消息的可靠性?</p><ul><li>生产端重试, 同步发送失败会根据retryTimesWhenSendFailed(默认3)重试; 异步发送失败由业务方实现重试逻辑</li><li>消息采用多副本存储, 默认每个Topic的MessageQueue分布在多个Broker节点上，支持主备冗余, 通过**DFS（分布式文件系统）**实现副本同步，确保副本间数据一致性; 所有消息在发送到Broker后，立即写入磁盘（默认异步刷盘），即使Broker宕机也不会丢失</li><li>消费端确认机制(ACK), 消费端消费完成后可主动提交Offset, 消费失败时消息会被重新投递到同一队列（默认重试次数 <code>maxReconsumeTimes=16</code>）,超过最大重试次数后，消息进入死信队列**（DLQ）**, 可通过消费死信队列的消息来进行一些业务补偿</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/N8mqYhk63Djcvk1ogSzsBg" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/N8mqYhk63Djcvk1ogSzsBg</a></p></blockquote><p><img src="'+s+'" alt="1741676091669"></p><ul><li>nameserver: 提供服务路由功能, 负责维护broker的数据信息; 对应的producer以及consumer在服务启动时通过nameserver获得broker地址信息</li></ul><h2 id="事务消息" tabindex="-1">事务消息 <a class="header-anchor" href="#事务消息" aria-label="Permalink to &quot;事务消息&quot;">​</a></h2><p><img src="'+l+'" alt="1741676284240"></p>',10)]))}const g=t(i,[["render",n]]);export{u as __pageData,g as default};
